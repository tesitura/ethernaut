# Vault

## Key

Sensible information in constructor remains hardcoded in the blockchain and accessible for an attacker. The

## Solution

1. Deploy the Vault.sol contract on Remix with an ad-hoc password as `AAAA` in bytes32 `0x4141414100000000000000000000000000000000000000000000000000000000`.
2. Verify in etherscan the bytecode of the contract creation, and check the last bytes32 where the password is.

```
0x608060405234801561001057600080fd5b506040516101623803806101628339818101604052602081101561003357600080fd5b810190808051906020019092919050505060016000806101000a81548160ff021916908315150217905550806001819055505060ee806100746000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063cf309012146037578063ec9b5b3a146055575b600080fd5b603d6080565b60405180821515815260200191505060405180910390f35b607e60048036036020811015606957600080fd5b81019080803590602001909291905050506091565b005b60008054906101000a900460ff1681565b80600154141560b55760008060006101000a81548160ff0219169083151502179055505b5056fea264697066735822122002b5089451a2cea75526e3987a324627db24a59e96866be8f37d6f35056f2f6164736f6c634300060c00334141414100000000000000000000000000000000000000000000000000000000
```

3. Gather the addr of the victims contract with `contract.address` and check in etherscan the bytecode to gather the hardcoded password.

```
608060405234801561001057600080fd5b506040516101653803806101658339818101604052602081101561003357600080fd5b810190808051906020019092919050505060016000806101000a81548160ff021916908315150217905550806001819055505060f1806100746000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063cf309012146037578063ec9b5b3a146057575b600080fd5b603d6082565b604051808215151515815260200191505060405180910390f35b608060048036036020811015606b57600080fd5b81019080803590602001909291905050506094565b005b6000809054906101000a900460ff1681565b80600154141560b85760008060006101000a81548160ff0219169083151502179055505b5056fea264697066735822122089d8dcab0ee2a6e0d4b11a8b0624f50e782fb879a941ed2f1d39cad24fdf2b1c64736f6c63430006030033412076657279207374726f6e67207365637265742070617373776f7264203a29
```

Hex `412076657279207374726f6e67207365637265742070617373776f7264203a29` to ascii -> `A very strong secret password :)`

4. Send this password as argument of `unlock` method

```
await contract.unlock("0x412076657279207374726f6e67207365637265742070617373776f7264203a29")
```

## Post solution information

It's important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.

To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs (https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/) provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter.

### Alternative solution information

```
Alignement depends on optimization of the evm, nevertheless:
[0] slot 1 -> bool public locked;
[1] slot 2 -> bytes32 private password;
await web3.eth.getStorageAt(contract.address, 1)


var pwd;
await web3.eth.getStorageAt(contract.address, 1, function(err, result){ pwd = result})
web3.utils.toAscii(0x412076657279207374726f6e67207365637265742070617373776f7264203a29)
```
